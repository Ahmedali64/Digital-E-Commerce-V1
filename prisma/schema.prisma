generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  // This is for docker only not for the app
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  CUSTOMER
}

enum Language {
  ENGLISH
  ARABIC
  FRENCH
  SPANISH
  GERMAN
  OTHER
}

enum DiscountType {
  PERCENTAGE
  FIXED_AMOUNT
}

enum OrderStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
  CANCELLED
}

enum PaymentMethod {
  CARD
  MOBILE_WALLET
  CASH          // This will not be used now maybe later in the future
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}


// --------------------- DataBase_Models ---------------------

model User {
  id                            String    @id @default(uuid())
  email                         String    @unique
  password                      String?
  firstName                     String
  lastName                      String
  role                          Role      @default(CUSTOMER)
  
  // OAuth Fields
  provider                      String?
  providerId                    String?   // User ID from OAuth provider
  avatar                        String?   // Profile picture URL

  // EmailVerification
  isEmailVerified               Boolean   @default(false)
  emailVerifiedAt               DateTime?
  emailVerificationToken        String?   @unique
  emailVerificationTokenExpiry  DateTime?

  // Password Reset
  passwordResetToken            String?   @unique
  passwordResetExpires          DateTime?

  createdAt                     DateTime  @default(now())
  updatedAt                     DateTime  @updatedAt

  // Relations
  refreshTokens           RefreshToken[]
  cart                    Cart?              
  discountUsages          DiscountUsage[]
  orders                  Order[]

  // The combination 'google-12345' is unique,
  // but 'github-12345' is still allowed.
  @@unique([provider, providerId])
}

model RefreshToken {
  id          String   @id @default(uuid())
  token       String   @db.Text
  userId      String
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@map("refresh_tokens")
}

model Product {
  id                  String    @id @default(uuid())

  // Basic info
  title               String
  authorName          String
  description         String    @db.Text
  isbn                String?   @unique // International Standard Book Number
  categoryId          String
  slug                String    @unique
  
  // Pricing
  price               Decimal  @db.Decimal(10, 2)
  discountPercentage  Int?
  saleEndsAt          DateTime?
  
  // Files
  coverImage          String
  coverImageSize      Int?      // in bytes
  coverImageOriginal  String?
  
  pdfFile             String
  pdfFileSize         Int?      // in bytes
  pdfFileOriginal     String?
  
  // Metadata
  pageCount           Int?
  language            Language  @default(ENGLISH)
  isPublished         Boolean
  publishedAt         DateTime?
  deletedAt           DateTime?
  publishedYear       Int?
  
  // Timestamps
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relations
  category   Category  @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  cartItems  CartItem[]
  orderItems OrderItem[]
  
  // Indexes for performance
  @@index([title])                    // Search by title
  @@index([authorName])               // Search by authorName
  @@index([price])                    // Sort by price
  @@index([saleEndsAt])               // For sale queries

  @@index([isPublished, deletedAt])   // For main query
  @@index([deletedAt])                // For soft delete checks

  @@index([categoryId, isPublished])  // Filter by category + published
  @@index([isPublished])              // Filter published books

  @@map("products")
}

model Category {
  id            String   @id @default(uuid())
  name          String    @unique
  slug          String    @unique
  description   String?   @db.Text
  image         String?
  imageSize     Int?      // in bytes
  imageOriginal String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Relations
  products      Product[]

  @@map("categories")
}

model Cart {
  id        String   @id @default(uuid())
  userId    String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  items     CartItem[]

  @@index([userId])
  @@index([expiresAt])
  @@map("carts")
}

model CartItem {
  id         String   @id @default(uuid())
  cartId     String
  productId  String
  priceAtAdd Decimal  @db.Decimal(10, 2) // Lock price when added
  createdAt  DateTime @default(now())

  cart    Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([cartId, productId]) // One product per cart only (no duplicates)
  @@index([cartId])
  @@index([productId])
  @@map("cart_items")
}

model DiscountCode {
  id               String    @id @default(uuid())
  code             String    @unique
  description      String?
  discountType     DiscountType
  discountValue    Decimal   @db.Decimal(10, 2) // Percentage or fixed amount
  minPurchase      Decimal?  @db.Decimal(10, 2) // Minimum cart value
  maxDiscount      Decimal?  @db.Decimal(10, 2) // Max discount amount (for percentage)
  usageLimit       Int?      // Total times it can be used
  usageCount       Int       @default(0)
  perUserLimit     Int?      // Times per user
  isActive         Boolean   @default(true)
  startsAt         DateTime?
  expiresAt        DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  usages           DiscountUsage[]

  @@index([code])
  @@index([isActive, expiresAt])
  @@map("discount_codes")
}

// Track who used which discount codes
model DiscountUsage {
  id             String   @id @default(uuid())
  discountCodeId String
  userId         String
  orderId        String?  // Link to order when created
  usedAt         DateTime @default(now())

  discountCode   DiscountCode @relation(fields: [discountCodeId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([discountCodeId])
  @@index([userId])
  @@map("discount_usages")
}

model Order {
  id                String      @id @default(uuid())
  userId            String
  
  subtotal          Decimal     @db.Decimal(10, 2)
  discountAmount    Decimal     @db.Decimal(10, 2)
  total             Decimal     @db.Decimal(10, 2)
  
  discountCodeId    String?
  discountCodeUsed  String?
  
  status            OrderStatus @default(PENDING)
  
  createdAt         DateTime    @default(now())
  paidAt            DateTime?
  updatedAt         DateTime    @updatedAt
  
  // Relations
  user              User        @relation(fields: [userId], references: [id])
  items             OrderItem[]
  payment           Payment?    // One-to-one with payment
  
  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("orders")
}

model OrderItem {
  id              String   @id @default(uuid())
  orderId         String
  productId       String
  
  title           String
  authorName      String
  price           Decimal  @db.Decimal(10, 2)
  
  pdfFile         String
  
  createdAt       DateTime @default(now())
  
  order           Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product         Product  @relation(fields: [productId], references: [id])
  
  @@index([orderId])
  @@index([productId])
  @@map("order_items")
}

model Payment {
  id                    String        @id @default(uuid())
  orderId               String        @unique  // One payment per order
  
  // Paymob specific
  paymobTransactionId   String?       @unique  // Paymob's ID for this payment
  paymobOrderId         String?
  paymentMethod         PaymentMethod?
  
  // Money
  amount                Decimal       @db.Decimal(10, 2)
  currency              String        @default("EGP")
  
  status                PaymentStatus @default(PENDING)
  
  // Tracking
  paidAt                DateTime?
  failureReason         String?       @db.Text  // Why it failed (if it did)
  
  // Webhook verification
  webhookReceived       Boolean       @default(false)
  webhookData           Json?         // Store raw webhook for debugging
  
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  
  // Relations
  order                 Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  @@index([orderId])
  @@index([paymobTransactionId])
  @@index([status])
  @@map("payments")
}